{"pages":[],"posts":[{"title":"Android APP Icon規範","text":"簡介Android APP的Icon規範與上架時會用到的圖片說明。 說明本文介紹最基本的Android APP Icon 規格，最後亦有上架時會用到的圖片說明。 1 Launcher icon:最基本的app icon，主要在launcher內顯示，PNG圖檔中需要包含背景。(ic_launcher.png) 2 Launcher icon-圓形:可設可不設，不設的話，視launcher而定，PNG圖檔中需要包含背景。(ic_launcher_round.png) 3 Launcher foreground:由前景與背景組成，為可自動調整的圖示，讓 launcher 決定 icon 的形狀。前景圖背景需為透明。(ic_launcher_foreground.png) 4 Launcher background:乘上。由前景與背景組成，為可自動調整的圖示，讓 launcher 決定 icon 的形狀。背景可直接用程式寫入需要的色碼。 範例AndroidManifest 1234&lt;application android:icon=&quot;@mipmap/ic_launcher&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&lt;/application&gt; ic_launcher.xml 與 ic_launcher_round.xml的內容相同 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;adaptive-icon xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;background android:drawable=&quot;@color/noteBG&quot;/&gt; &lt;foreground android:drawable=&quot;@mipmap/ic_launcher_foreground&quot;/&gt;&lt;/adaptive-icon&gt; 檔案調成Project,將以下檔案放入app/src/main/res中 mipmap-anydpi-v26 ic_launcher.xml ic_launcher_round.xml mipmap-hdpi ic_launcher.png (72*72) ic_launcher_round.png (72*72) ic_launcher_foreground.png (162*162) mipmap-mdpi ic_launcher.png (48*48) ic_launcher_round.png (48*48) ic_launcher_foreground.png (108*108) mipmap-xhdpi ic_launcher.png (96*96) ic_launcher_round.png (96*96) ic_launcher_foreground.png (216*216) mipmap-xxhdpi ic_launcher.png (144*144) ic_launcher_round.png (144*144) ic_launcher_foreground.png (324*324) mipmap-xxxhdpi ic_launcher.png (192*192) ic_launcher_round.png (192*192) ic_launcher_foreground.png (432*432) 注意圖畫建議用1024*1024px 繪製，畫完可將檔案丟到 https://appicon.co/ 這個網站，該網站會把圖片製成對應的ic_launcher大小，並放入對應的資料夾中。 在繪製ic_launcher_foreground的圖檔時，一定要留邊(用1024*1024px 的畫布繪製時，需畫在以中心為圓心，直徑685px的圓形裡面) 上架圖如果要上架APP到Google Play還需另外準備1 Google Play Icon:不會放進app入面，用於Google Play上架。(512*512) 2 Google Play 主題圖片:不會放進app入面，用於Google Play上架。(1024*500) 3 APP截圖 4 7吋APP截圖 5 10吋APP截圖 參考資料https://medium.com/ericlog/android-app-icon-specification-2e57c96b16b0 dpi-px-pt-dp-sp教學https://blog.akanelee.me/2018/07/31/dpi-px-pt-dp-sp/","link":"/2021/01/20/Android%20APP%20Icon%E8%A6%8F%E7%AF%84/"},{"title":"Android ForegroundService","text":"簡介使用前台服務須創造一通知，讓用戶主動意識到您的應用正在前台執行任務，並且正在消耗系統資源。除非服務已停止或從前台刪除，否則無法取消該通知。 前台服務的應用示例包括：在前台服務中播放音樂的音樂播放器應用。該通知可能會顯示當前正在播放的歌曲。健身應用程序，在收到用戶的許可後，將其記錄在前台服務中。該通知可能會顯示用戶在當前健身會話期間旅行的距離。 說明權限Android 9（API級別28）或更高版本，使用必須添加權限 1&lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt; 開啟foreground service12345678910111213141516171819Intent notificationIntent = new Intent(this, MainActivity.class);PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);Notification notification = new NotificationCompat.Builder(this, CHANNEL_ID) .setContentTitle(&quot;下拉列表中的Title&quot;) .setContentText(&quot;要显示的内容 要显示的内容 要显示的内容 要显示的内容&quot;) //過多的字以...呈現 //.setStyle(new NotificationCompat.BigTextStyle().bigText(&quot;要显示的内容 要显示的内容 要显示的内容 要显示的内容&quot;)) //顯示完整內容 .setSmallIcon(R.drawable.ic_cake)// 設置狀態攔下小圖標，建議大小為32x32 .setContentIntent(pendingIntent) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.drawable.smile)) // 設置狀態攔下大圖標，建議用PNG，大小為64x64 .setWhen(System.currentTimeMillis())// 設置通知發生時間 .addAction(R.drawable.ic_launcher_foreground, &quot;Stop&quot;, pStopSelf) .addAction(R.drawable.ic_launcher_foreground, &quot;NewActivity&quot;, newActivity) .setDefaults(Notification.DEFAULT_ALL) // 加上提醒效果:震動(DEFAULT_VIBRATE)，音效(DEFAULT_VIBRATE)，燈光(DEFAULT_LIGHT) //若有用到震動則需在AndroidManifest.xml加入權限&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt; .build();startForeground(1, notification); 提醒使用Service需在AndroidManifest.xml加入Service 類別 1234&lt;service android:name=&quot;.ForegroundService&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; /&gt; 範例MainActivity12345678910111213141516171819202122232425262728293031323334package com.example.androidforegroundserviceexample;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.view.View;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } public void startService(View view) { Intent serviceIntent = new Intent(this, ForegroundService.class); serviceIntent.putExtra(&quot;inputExtra&quot;, &quot;Start Foreground Service in Android&quot;); //方法一 serviceIntent.setAction(&quot;STARTFOREGROUND_ACTION&quot;); startService(serviceIntent); //方法二 // startService(serviceIntent); } public void stopService(View view) { Intent serviceIntent = new Intent(this, ForegroundService.class); serviceIntent.putExtra(&quot;inputExtra&quot;, &quot;Stop Foreground Service in Android&quot;); //方法一 serviceIntent.setAction(&quot;STOPFOREGROUND_ACTION&quot;); startService(serviceIntent); //方法二 //stopService(serviceIntent); }} activity_main1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/buttonStartService&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Start Service&quot; android:onClick=&quot;startService&quot; /&gt; &lt;Button android:id=&quot;@+id/buttonStopService&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Stop Service&quot; android:onClick=&quot;stopService&quot; /&gt;&lt;/LinearLayout&gt; ForegroundService1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.example.androidforegroundserviceexample;import android.app.Notification;import android.app.NotificationChannel;import android.app.NotificationManager;import android.app.PendingIntent;import android.app.Service;import android.content.Intent;import android.graphics.BitmapFactory;import android.media.MediaPlayer;import android.os.Build;import android.os.IBinder;import android.util.Log;import androidx.annotation.Nullable;import androidx.core.app.NotificationCompat;public class ForegroundService extends Service { @Override public void onCreate() { super.onCreate(); Log.v(&quot;ForegroundService&quot;,&quot;onCreate&quot;); } @Override public int onStartCommand(Intent intent, int flags, int startId) { //通知跳轉業面 PendingIntent newActivity = PendingIntent.getActivity(this, 0, new Intent(this, NewActivity.class), 0); //通知關閉Service Intent serviceIntent = new Intent(this, ForegroundService.class); serviceIntent.putExtra(&quot;inputExtra&quot;, &quot;Stop Foreground Service in Android&quot;); serviceIntent.setAction(&quot;STOPFOREGROUND_ACTION&quot;); PendingIntent pStopSelf = PendingIntent.getService(this, 0, serviceIntent, PendingIntent.FLAG_CANCEL_CURRENT); /************************/ String input = intent.getStringExtra(&quot;inputExtra&quot;); Log.v(&quot;ForegroundService&quot; , input); Intent notificationIntent = new Intent(this, MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0); Notification notification = new NotificationCompat.Builder(this, CHANNEL_ID) .setContentTitle(&quot;下拉列表中的Title&quot;) .setContentText(&quot;要显示的内容 要显示的内容 要显示的内容 要显示的内容&quot;) //過多的字以...呈現 //.setStyle(new NotificationCompat.BigTextStyle().bigText(&quot;要显示的内容 要显示的内容 要显示的内容 要显示的内容&quot;)) //顯示完整內容 .setSmallIcon(R.drawable.ic_cake)// 設置狀態攔下小圖標，建議大小為32x32 .setContentIntent(pendingIntent) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.drawable.smile)) // 設置狀態攔下大圖標，建議用PNG，大小為64x64 .setWhen(System.currentTimeMillis())// 設置通知發生時間 .addAction(R.drawable.ic_launcher_foreground, &quot;Stop&quot;, pStopSelf) .addAction(R.drawable.ic_launcher_foreground, &quot;NewActivity&quot;, newActivity) .setDefaults(Notification.DEFAULT_ALL) // 加上提醒效果:震動(DEFAULT_VIBRATE)，音效(DEFAULT_VIBRATE)，燈光(DEFAULT_LIGHT) //若有用到震動則需在AndroidManifest.xml加入權限&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt; .build(); //方法一 if (intent.getAction().equals( &quot;STARTFOREGROUND_ACTION&quot;)) { Log.i(&quot;ForegroundService&quot;, &quot;Received Start Foreground Intent &quot;); startForeground(1, notification); } else if (intent.getAction().equals( &quot;STOPFOREGROUND_ACTION&quot;)) { Log.i(&quot;ForegroundService&quot;, &quot;Received Stop Foreground Intent&quot;); stopForeground(true); stopSelfResult(startId); //stopSelf();//停止Service } //方法二 // startForeground(1, notification); return START_NOT_STICKY; } @Override public void onDestroy() { super.onDestroy(); } @Nullable @Override public IBinder onBind(Intent intent) { return null; }} onStartCommand() 的回傳值決定 Service 被殺掉時要怎麼做對應的處理:START_NOT_STICKY：如果系統在 onStartCommand() 後終止 Service，除非有待決的 intent 要傳送，否則請「不要」建立 Service。START_STICKY：如果系統在 onStartCommand() 後終止 Service，請重新建立 Service 並呼叫 onStartCommand()，但「不要」重新傳送最後的 intent。 相反地，除非有待決的 intent 要啟動 service，否則系統會使用 null intent 呼叫，適用於媒體播放程式 。START_REDELIVER_INTENT：如果系統在 onStartCommand() 後終止 Service，請重新建立 Service 並使用傳送至 Service的最後 intent 呼叫onStartCommand()。適用的 Service 為主動執行如下載檔案等應該立即繼續的工作。 PendingIntent有以下flag：FLAG_CANCEL_CURRENT:如果當前系統中已經存在一個相同的PendingIntent對象，那麼就將先將已有的PendingIntent取消，然後重新生成一個PendingIntent對象。FLAG_NO_CREATE:如果當前系統中不存在相同的PendingIntent對象，系統將不會創建該PendingIntent對象而是直接返回null。FLAG_ONE_SHOT:該PendingIntent只作用一次。FLAG_UPDATE_CURRENT:如果系統中已存在該PendingIntent對象，那麼系統將保留該PendingIntent對象，但是會使用新的Intent來更新之前PendingIntent中的Intent對像數據，例如更新Intent中的Extras。創建PendingIntent方式：PendingIntent.getActivity (context, requestCode, broadIntent, flags)PendingIntent.getBroadcast(context,requestCode, broadIntent, flags)PendingIntent.getService (context, requestCode, broadIntent, flags) 參考資料官方文檔https://developer.android.com/guide/components/foreground-servicesForeground Servicehttps://androidwave.com/foreground-service-android-example/PendingIntenthttps://blog.csdn.net/yangwen123/article/details/8019739 檔案下載檔案下載: Download Code","link":"/2020/11/13/Android%20ForegroundService/"},{"title":"Android Gif 使用","text":"簡介GifImageView、GifImageButton、GifTextureView、GifTextView的使用 說明在gradle(Project)中的repositories加入mavenCentral() (註:共有兩處需要添加) 1234567891011121314151617181920212223buildscript { repositories { google() jcenter() mavenCentral() //添加處 } dependencies { classpath &quot;com.android.tools.build:gradle:4.0.1&quot; }}allprojects { repositories { google() jcenter() mavenCentral() //添加處 }}task clean(type: Delete) { delete rootProject.buildDir} 在gradle(Module:app)中添加 12implementation 'pl.droidsonroids.gif:android-gif-drawable:1.1.17' 添加後即可使用GifImageView、GifImageButton、GifTextureView、GifTextView 範例activity 123456&lt;pl.droidsonroids.gif.GifImageView android:id=&quot;@+id/iv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/giphy&quot;/&gt; 參考資料https://medium.com/@skywing0527/android自學筆記-15-使用imageview播放gif-fb184c2aea56","link":"/2021/01/18/Android%20Gif%E5%9C%96%E6%AA%94%E4%BD%BF%E7%94%A8/"},{"title":"Android Google 登入","text":"簡介Google API 實現登入功能 將 Google 登錄機制加入的應用中，讓用戶可使用自己的 Google 帳號進行 Firebase 身份驗證 說明需先申辦Firebase的帳號，並將專案與Firebase的連接。以下將演示登入專案的實現方。 專案與Firebase的連接開啟新專案，點選Tool-&gt;Firebase,待跳出右邊視窗後，選Authentication-&gt;Email and password authentication 點開後將專案將專案與Firebase進行連結不需要事先到Firebase中開啟新專案，直接在以下步驟中創建(Connect your app to Firebase)並連結(Add Firebase Authentication to your app)即可 接著到自己的Firebase中的控制台 https://console.firebase.google.com/u/3/ 點選剛剛創建的專案 接著從旁邊的authentication中進入開啟Google登入 再回到Android Studio 點選右邊的 gradle-&gt;點開專案-&gt;Task-&gt;android-&gt;signingReport便可以看到SHA1和SHA-256，等等需要將其加入Firebase的專案中(執行APP時，記得將上面的模式調回app才可以執行) 到Firebase的專案總攬-&gt;專案設定 在專案設定中的一般設定裡，將剛剛的SHA1和SHA-256新增上去，設定好後，下載google-services.json檔 將google-services.json檔放入android專案中的app 補充說明官方教學文件可以點選android studio的連結進去 https://firebase.google.com/docs/auth/android/google-signin?utm_source=studio 如果要將APP上架到Play Store，需要到Firebase中設定專案與Play Store的連結 android studio gradle設定build.gradle(Project) 加入 classpath ‘com.google.gms:google-services:4.2.0’ 1234567891011buildscript { repositories { google() jcenter() } dependencies { classpath &quot;com.android.tools.build:gradle:4.0.1&quot; classpath 'com.google.gms:google-services:4.2.0' //GoogleSign }} build.gradle(app)) 123456789101112131415// Import the BoM for the Firebase platformimplementation platform('com.google.firebase:firebase-bom:26.2.0')// Declare the dependency for the Firebase Authentication library// When using the BoM, you don't specify versions in Firebase library dependenciesimplementation 'com.google.firebase:firebase-auth'// Also declare the dependency for the Google Play services library and specify its versionimplementation 'com.google.android.gms:play-services-auth:19.0.0'implementation 'com.google.firebase:firebase-database:17.0.0'implementation 'com.google.firebase:firebase-core:17.0.0'implementation 'com.google.firebase:firebase-firestore:19.0.0'//google用戶圖片implementation 'com.github.bumptech.glide:glide:4.12.0'annotationProcessor 'com.github.bumptech.glide:compiler:4.12.0' 程式碼MainActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package com.example.googlesignin;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.net.Uri;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.TextView;import android.widget.Toast;import com.bumptech.glide.Glide;import com.google.android.gms.auth.api.signin.GoogleSignIn;import com.google.android.gms.auth.api.signin.GoogleSignInAccount;import com.google.android.gms.auth.api.signin.GoogleSignInClient;import com.google.android.gms.auth.api.signin.GoogleSignInOptions;import com.google.android.gms.common.SignInButton;import com.google.android.gms.common.api.ApiException;import com.google.android.gms.tasks.OnCompleteListener;import com.google.android.gms.tasks.Task;public class MainActivity extends AppCompatActivity { private GoogleSignInClient mGoogleSignInClient; private SignInButton signInButton; Button signOutBtn; TextView nameTV,mailTV,idTV; ImageView imageIV; private int RC_SIGN_IN = 0; String TAG = &quot;GoogleSignIn&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); nameTV = findViewById(R.id.nameTV); idTV = findViewById(R.id.idTV); mailTV = findViewById(R.id.mailTV); imageIV = findViewById(R.id.imageIV); signOutBtn = findViewById(R.id.signOutBtn); signInButton = findViewById(R.id.sign_in_button); creatRequest(); //配置Google登入 userSignStatus();//檢查使用者是否已經有登入 signInButton.setOnClickListener(new View.OnClickListener()//不用onClick的方式，因為需要在初始配置中先獲得mGoogleSignInClient { @Override public void onClick(View view) { signIn(); } }); } private void creatRequest() { // Configure Google Sign In GoogleSignInOptions gso = new GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN) .requestIdToken(getString(R.string.default_web_client_id)) //R.string.default_web_client_id需要將系統執行一次，讓他產生 .requestEmail() .build(); mGoogleSignInClient = GoogleSignIn.getClient(this,gso); } private void userSignStatus()//檢查使用者是否已經有登入，有的話直接跳到ProfileActivity { GoogleSignInAccount signInAccount = GoogleSignIn.getLastSignedInAccount(this); if(signInAccount != null) { idTV.setText(signInAccount.getId()); nameTV.setText(signInAccount.getDisplayName()); mailTV.setText(signInAccount.getEmail()); Uri AccountUri = signInAccount.getPhotoUrl(); Glide.with(this).load(String.valueOf(AccountUri)).into(imageIV); signOutBtn.setVisibility(View.VISIBLE); signInButton.setVisibility(View.INVISIBLE); } } private void signIn() { Intent signIntent = mGoogleSignInClient.getSignInIntent(); startActivityForResult(signIntent,RC_SIGN_IN); } @Override public void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); // Result returned from launching the Intent from GoogleSignInApi.getSignInIntent(...); if (requestCode == RC_SIGN_IN) { Task&lt;GoogleSignInAccount&gt; task = GoogleSignIn.getSignedInAccountFromIntent(data); handleSignInResult(task); } } private void handleSignInResult(Task&lt;GoogleSignInAccount&gt; completedTask) { try { // Google Sign In was successful, authenticate with Firebase GoogleSignInAccount signInAccount = completedTask.getResult(ApiException.class); idTV.setText(signInAccount.getId()); nameTV.setText(signInAccount.getDisplayName()); mailTV.setText(signInAccount.getEmail()); Uri AccountUri = signInAccount.getPhotoUrl(); Glide.with(this).load(String.valueOf(AccountUri)).into(imageIV); signOutBtn.setVisibility(View.VISIBLE); signInButton.setVisibility(View.INVISIBLE); } catch (ApiException e) { // Google Sign In failed, update UI appropriately Log.w(TAG, &quot;Google sign in failed&quot;, e); Toast.makeText(this,e.getMessage(),Toast.LENGTH_SHORT).show(); } } public void signOut(View view) { mGoogleSignInClient.signOut() .addOnCompleteListener(this, new OnCompleteListener&lt;Void&gt;() { @Override public void onComplete(@NonNull Task&lt;Void&gt; task) { Toast.makeText(MainActivity.this,&quot;Signed Out&quot;,Toast.LENGTH_SHORT).show(); } }); idTV.setText(&quot;&quot;); nameTV.setText(&quot;&quot;); mailTV.setText(&quot;&quot;); imageIV.setImageResource(R.drawable.ic_baseline_account_box_24); signOutBtn.setVisibility(View.INVISIBLE); signInButton.setVisibility(View.VISIBLE); }} activity_main 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;50dp&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageIV&quot; android:layout_gravity=&quot;center&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;200dp&quot; android:src=&quot;@drawable/ic_baseline_account_box_24&quot; /&gt; &lt;TextView android:id=&quot;@+id/idTV&quot; android:layout_gravity=&quot;center&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;TextView android:id=&quot;@+id/nameTV&quot; android:layout_gravity=&quot;center&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;TextView android:id=&quot;@+id/mailTV&quot; android:layout_gravity=&quot;center&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;/LinearLayout&gt; &lt;com.google.android.gms.common.SignInButton android:id=&quot;@+id/sign_in_button&quot; android:layout_width=&quot;match_parent&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;Button android:layout_alignParentBottom=&quot;true&quot; android:id=&quot;@+id/signOutBtn&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;signOut&quot; android:text=&quot;Sign Out&quot; android:background=&quot;#abcabc&quot; android:visibility=&quot;invisible&quot; /&gt;&lt;/RelativeLayout&gt; 參考資料https://www.youtube.com/watch?v=t-yZUqthDMMhttps://www.youtube.com/watch?v=E1eqRNTZqDM官方教學: https://firebase.google.com/docs/auth/android/google-signin?utm_source=studio 檔案下載檔案下載: Download Code 登入後進入另一個Activity顯示資料檔案下載: Download Code","link":"/2021/02/06/Android%20Google%20%E7%99%BB%E5%85%A5/"},{"title":"Android Log","text":"簡介在開發過程中，Log可以用來除錯、追蹤、紀錄或是顯示訊息等等，可以自由的靈活運用，是開發過程中非常便利的工具。 說明常用的Log有五種等級，分別為:VERBOSE - Log.v()DEBUG - Log.d()INFO - Log.i()WARN - Log.w()ERROR - Log.e() Log.v()會顯示的資訊包含:Log.v()、Log.d()、 Log.i()、Log.w()、Log.e()Log.d()會顯示的資訊包含:Log.d()、Log.i()、Log.w()、Log.e()Log.i()會顯示的資訊包含:Log.i()、Log.w()、Log.e()Log.w()會顯示的資訊包含:Log.w()、Log.e()Log.e()會顯示的資訊包含:Log.e() 可以到Android Studio中的 File -&gt; Setting -&gt; Editor -&gt; Color Scheme 中找到 Android Logcat 來設定Log的顏色。通常可以將其在Logcat顯示的顏色設為:VERBOSE -黑DEBUG - 藍INFO - 綠WARN - 橙ERROR - 紅 最後記得按Apply 使用範例1private static final String TAG = &quot;MainActivity&quot;; 在程式需要的位置加入即可 12345Log.v(TAG,&quot;我是Log.v&quot;);Log.d(TAG,&quot;我是Log.d&quot;);Log.i(TAG,&quot;我是Log.i&quot;);Log.w(TAG,&quot;我是Log.w&quot;);Log.e(TAG,&quot;我是Log.e&quot;); 成果圖: 註:可以在圖中圈起來的地方去設定Logcat的過濾資料，來讀取自己想要的資訊。 參考資料https://developer.android.com/reference/android/util/Log#public-methods","link":"/2021/01/23/Android%20Log/"},{"title":"Android MVVM基本使用","text":"簡介基本MVVM架構(含ViewMode、DataBinding) 說明MVVM是Model-View-ViewModel的簡稱，三者扮演的角色為： Model：管理專案的資料來源，如API、資料庫和SharedPreference等，並回應來自ViewModel的資料請求。View：可以是Activity、Fragment或custom view，用來顯示UI和監聽使用者動作。當使用者跟UI有互動時，會將指令傳給ViewModel，透過ViewModel來獲得所需的資料並顯示。ViewModel：接收View的指令並對Model請求資料給View使用。 ViewModel中的3種資料儲存1.SavedState:可在資料改變時，即時顯示在View上，並保護資料不會因為進入後台而消失。(註:若是再有多個Fragment要使用SavedState，可以將其全寫在Fragment們的Activity中) 2.LiveData:可在資料改變時，即時顯示在View上。 3.一般:直接在ViewModel中宣告即可使用 基本上，ViewModel不會因為進入後台便被銷毀，但在程式擱置過久、空間不夠，或手機設定上不允許程式進入後台活動，ViewModel便會被銷毀。雖然隨著Activity的重建，ViewModel亦可以跟著重建，不過重建後資料都會消失。 範例Module gradle 添加依賴dependencies 1234//ViewModelimplementation 'androidx.lifecycle:lifecycle-extensions:2.2.0'//SavedStateimplementation 'androidx.lifecycle:lifecycle-viewmodel-savedstate:1.0.0-alpha01' defaultConfig 12//DataBindingdataBinding{ enabled true} MyViewModel.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import androidx.lifecycle.MutableLiveData;import androidx.lifecycle.SavedStateHandle;import androidx.lifecycle.ViewModel;import java.util.ArrayList;import java.util.List;public class MyViewModel extends ViewModel{ /**SavedState*/ // 使用SavedState需添加 implementation 'androidx.lifecycle:lifecycle-viewmodel-savedstate:1.0.0' private SavedStateHandle handle; //ViewModel的建構子需傳送SavedStateHandle public MyViewModel(SavedStateHandle handle) { this.handle = handle; } //取得SavedStateNumber public MutableLiveData&lt;Integer&gt; getSavedState_Number() { if(!handle.contains(MainActivity.SavedState_Number)) { //初始化 handle.set(MainActivity.SavedState_Number,0); } return handle.getLiveData(MainActivity.SavedState_Number); } /**LiveData*/ private MutableLiveData&lt;Integer&gt; LiveData_Number; //取得LiveData public MutableLiveData&lt;Integer&gt; getLiveData_Number() { if(LiveData_Number == null) { LiveData_Number = new MutableLiveData&lt;&gt;(); LiveData_Number.setValue(0); } return LiveData_Number; } /**一般資料*/ private List&lt;String&gt; List0 = new ArrayList&lt;String&gt;(); //操作SavedState public void addSavedStateNumber() { getSavedState_Number().setValue(getSavedState_Number().getValue()+1); } //操作LiveData public void addLiveDataNumber() { getLiveData_Number().setValue(getLiveData_Number().getValue()+1); }} MainActivity.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import androidx.appcompat.app.AppCompatActivity;import androidx.databinding.DataBindingUtil;import androidx.lifecycle.SavedStateViewModelFactory;import androidx.lifecycle.ViewModelProvider;import android.os.Bundle;import com.example.viewmodelrestore.databinding.ActivityMainBinding;//使用DataBinding 需要再Gradle(app) android defaultConfig 裡添加 dataBinding{ enabled true}//並到Activity按小燈泡 將其轉換為BundingStylepublic class MainActivity extends AppCompatActivity { MyViewModel myViewModel; ActivityMainBinding binding; //SavedState的KEY(字串) public final static String SavedState_Number = &quot;my_number&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //setContentView(R.layout.activity_main);這行就不用了 //ViewModel myViewModel = new ViewModelProvider(this,new SavedStateViewModelFactory(getApplication(), this)) .get(MyViewModel.class);// 儲存ViewModel資料不背後台殺掉的舊方法// myViewModel = ViewModelProviders.of(this).get(MyViewModel.class);// if(savedInstanceState != null ) //儲存ViewModel方法一 舊方法 第一次開啟時會等於空// {// myViewModel.getNumber().setValue(savedInstanceState.getInt(KEY_NUMBER));// } //DataBinding binding = DataBindingUtil.setContentView(this,R.layout.activity_main); binding.setData(myViewModel); binding.setLifecycleOwner(this); /**呼叫|Activity元件*/ //binding.tv }// 儲存ViewModel資料不背後台殺掉的舊方法// @Override// protected void onSaveInstanceState(@NonNull Bundle outState)//儲存ViewModel方法一 舊方法: 後臺如果沒有辦法保存ViewModel時 用這保存// {// super.onSaveInstanceState(outState);//// outState.putInt(KEY_NUMBER,myViewModel.getNumber().getValue());// }} activity_main.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;variable name=&quot;data&quot; type=&quot;com.example.viewmodelrestore.MyViewModel&quot; /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#c5d3a7&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; android:text=&quot;SavedStateData&quot; android:textSize=&quot;30dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:background=&quot;@drawable/textview_bg&quot; android:gravity=&quot;center&quot; android:text=&quot;@{String.valueOf(data.savedState_Number)}&quot; android:textSize=&quot;30dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.498&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;0.272&quot; /&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:onClick=&quot;@{()-&gt;data.addSavedStateNumber()}&quot; android:text=&quot;+1&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.498&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;0.368&quot; /&gt; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#d3a7bd&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:text=&quot;LiveData&quot; android:textSize=&quot;30dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv2&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:background=&quot;@drawable/textview_bg&quot; android:gravity=&quot;center&quot; android:text=&quot;@{String.valueOf(data.getLiveData_Number())}&quot; android:textSize=&quot;30dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.498&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;0.272&quot; /&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:onClick=&quot;@{()-&gt;data.addLiveDataNumber()}&quot; android:text=&quot;+1&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.498&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;0.368&quot; /&gt; /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; textview_bg.xml (res/drawable)123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;solid android:color=&quot;#FFFFFF&quot;/&gt; &lt;corners android:radius=&quot;10dp&quot;/&gt; &lt;stroke android:width=&quot;3dp&quot; android:color=&quot;#728ea3&quot;/&gt;&lt;/shape&gt; 參考資料https://www.youtube.com/watch?v=uonkx0G2lng&amp;list=PLPh5-KovAYtFyX5elSTT9wEMt0HxMhR7L&amp;index=14 檔案下載檔案下載: Download Code","link":"/2020/11/30/Android%20MVVM%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"Android Permission","text":"簡介權限的目的是保護Android用戶的隱私。在Android6 sdk23 以上要求使用。 說明普通權限對用戶的隱私或其他應用的操作風險很小。需在Manifest聲明，但不需詢問使用者同意便可使用。 危險權限需要涉及用戶私人信息、數據或資源的區域，或可能影響用戶存儲的數據，或是其他應用程序的操作。需在Manifest聲明，且需詢問使用者的同意才可使用。 危險權限-權限組所有危險的 Android 系統權限都屬於權限組。向用戶要求權限的對話框不會描述該具體權限，例如，如果應用請求 READ_CONTACTS 權限，系統對話框只說明該應用需要訪問設備的聯繫信息。而在該權限組中，只要有其中一權限被使用者允許，則該權限組的所有權限皆視為允許。 權限組查詢https://developer.android.com/guide/topics/security/permissions?hl=zh-cn#%E6%9D%83%E9%99%90%E7%BA%A7%E5%88%AB權限說明https://developer.android.com/reference/android/Manifest.permission#SMS_FINANCIAL_TRANSACTIONS 範例聲明權限AndroidManifest 1234567891011//定位權限組//網路定位&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;//GPS&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;//訊息權限組&lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_SMS&quot; /&gt; 檢查、要求權限檢查權限:ContextCompat.checkSelfPermission(context, Manifest.permission.權限名)回傳-1:不允許此權限回傳0:允許此權限 要求權限:this.requestPermissions(new String[]{Manifest.permission.權限名}, requestCode); 兩個以上權限組的範例:12345678if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED || ContextCompat.checkSelfPermission(this, Manifest.permission.RECEIVE_SMS) != PackageManager.PERMISSION_GRANTED){ if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) // 判斷裝置版本是否大於SDK23 { this.requestPermissions(new String[]{Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.RECEIVE_SMS}, 1); }} 同一權限組的只需派一代表檢查與對其進行權限要求即可。 權限要求對話框的互動結果1234567891011121314@Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == 1) { if (grantResults[0] != PackageManager.PERMISSION_GRANTED) { Toast.makeText(this, &quot;拒絕Location權限會導致程式中某些功能無法如常運作&quot;, Toast.LENGTH_SHORT).show(); } if (grantResults[1] != PackageManager.PERMISSION_GRANTED) { Toast.makeText(this, &quot;拒絕SMS權限會導致程式中某些功能無法如常運作&quot;, Toast.LENGTH_SHORT).show(); } } } 註:後面的Toast指令會覆蓋掉前面的 補充使用者若是多次拒絕權限對話框的詢問或是對此權限勾選”不再詢問”，會導致requestPermissions將不再工作(用shouldShowRequestPermissionRationale來判斷)。此時可將使用者導到APP設定畫面 1234567//裝置未授予此權限，且拒絕被訪問權限，直接導到設定頁面if(!ActivityCompat.shouldShowRequestPermissionRationale(MainActivity.this, Manifest.permission.ACCESS_FINE_LOCATION ) &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED){ openAppSettingsIntent();} shouldShowRequestPermissionRationale:回傳true(允許說明) 1.請求權限被禁止，但未選擇【不再提醒】回傳false(不須再說明–&gt;無法使用requestPermissions):1.第一次請求權限時 2.使用者堅決不給權限，已勾選別再詢問我 3.已允許權限 1234567private void openAppSettingsIntent()//前往系統設定頁面{ //因無法直接導到「權限」選單裡，只能到應用程式資訊頁面 --&gt;ACTION_APPLICATION_DETAILS_SETTINGS Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS, Uri.fromParts(&quot;package&quot;, getPackageName(), null)); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent);} 完整程式碼123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import androidx.appcompat.app.AppCompatActivity;import androidx.core.app.ActivityCompat;import androidx.core.content.ContextCompat;import android.Manifest;import android.content.Intent;import android.content.pm.PackageManager;import android.net.Uri;import android.os.Build;import android.os.Bundle;import android.provider.Settings;import android.widget.Toast;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED || ContextCompat.checkSelfPermission(this, Manifest.permission.RECEIVE_SMS) != PackageManager.PERMISSION_GRANTED) { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) // 判斷裝置版本是否大於SDK23 { this.requestPermissions(new String[]{Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.RECEIVE_SMS}, 1); } } //裝置未授予此權限，且拒絕被訪問權限，直接導到設定頁面 if(!ActivityCompat.shouldShowRequestPermissionRationale(MainActivity.this, Manifest.permission.ACCESS_FINE_LOCATION ) &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED ) { openAppSettingsIntent(); } /**shouldShowRequestPermissionRationale * 回傳true(允許說明) 1.請求權限被禁止，但未選擇【不再提醒】 * 回傳false(不須再說明--&gt;無法使用requestPermissions):1.第一次請求權限時 2.使用者堅決不給權限，已勾選別再詢問我 3.已允許權限 */ } @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == 1) { if (grantResults[0] != PackageManager.PERMISSION_GRANTED) { Toast.makeText(this, &quot;拒絕Location權限會導致程式中某些功能無法如常運作&quot;, Toast.LENGTH_SHORT).show(); } if (grantResults[1] != PackageManager.PERMISSION_GRANTED) { Toast.makeText(this, &quot;拒絕SMS權限會導致程式中某些功能無法如常運作&quot;, Toast.LENGTH_SHORT).show(); } } } private void openAppSettingsIntent()//前往系統設定頁面 { //無法直接導到「權限」選單裡，只能到應用程式資訊頁面 --&gt;ACTION_APPLICATION_DETAILS_SETTINGS Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS, Uri.fromParts(&quot;package&quot;, getPackageName(), null)); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); }} 參考資料官方文檔https://developer.android.com/guide/topics/permissions/overview官方範例https://developer.android.com/training/permissions/requesting範例https://myapollo.com.tw/zh-tw/polly-android-runtime-permissions/","link":"/2020/11/17/Android%20Permission/"},{"title":"Android SdkVersion","text":"簡介介紹minSdkVersion、compileSdkVersion、targetSdkVersion可通過API的級別來表示應用程序與Android平台的一個或多個版本的兼容性 說明minSdkVersionApp最小可以支援的版本。(可由Android Studio查詢現有行動裝置的版本比例，藉此確定使用minSdkVersion級別)在Play Store中，用戶的裝置版本若小於APP的minSdkVersion，那Play Store便不向該用戶顯示此App。 在開發時，會依minSdkVersion來警告你，是否用了高於minSdkVersion的API，避免調用不存在的API，造成運行問題。 compileSdkVersionGradle用的AndroidSDK編譯版本。官方強烈推薦用最新的SDK進行編譯(在開發中的應用程式，提醒已棄用的API，也為使用新的API做好準備) targetSdkVersionApp最合適的版本，最低通常須依Googlee規定也是向前兼容的主要依據:如果裝置API級別高於您的應用程序聲明的targetSdkVersion，則係統可能會啟用兼容性行為，以確保您的應用程序繼續按您期望的方式運行。舉例:在Android 6.0（API 级别23）及更高版本中，使用一些相對敏感的權限時，需要徵求用戶的許可。若target sdk &lt; 23 ，Android 則會自動用 23 以下的 api 運行，而若是APP運行在android 6.0或以上版本，且target sdk&gt;=23，便需要向其徵求敏感權限的使用。 範例設定位置build.gradle 1234567891011121314android { compileSdkVersion 30 buildToolsVersion &quot;30.0.1&quot; defaultConfig { applicationId &quot;com.xxx.xxx&quot; minSdkVersion 18 targetSdkVersion 26 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; } 版本判斷及應變123456if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {}else{} 參考資料官方文檔 https://developer.android.com/guide/topics/manifest/uses-sdk-elementhttps://willy2016.pixnet.net/blog/post/215759103","link":"/2020/11/17/Android%20SdkVersion/"},{"title":"Android SharedPreferences","text":"簡介儲存簡單資料例如：帳號資料、遊戲關卡、APP喜愛設定等 說明資料儲存在手機中APP的一個專用目錄下(每個APP都會有一個專用目錄):data/data/[package.name]/shared_prefs/[name.xml] EX:data/data/com.example.sharepreferences/shared_prefs/myData.xml該檔案可在Android Studio中的Device File Explore中察看 資料儲存格式為XML檔 若使用者在設定中清除APP 儲存空間，則SharedPreferences所存的檔案會被清空(為Android本地資料) 範例創建1SharedPreferences shp = getSharedPreferences(檔案名稱,Context.MODE_PRIVATE); 若沒指定存檔名稱，默認為該Activity的名字 1SharedPreferences shp = getPreferences(Context.MODE_PRIVATE); Value Constant 說明 0 MODE_PRIVATE 常用，只允許該 APP 存取 1 MODE_WORLD_READABLE 不建議，所有 APP 都能讀取 2 MODE_WORLD_WRITEABLE 不建議，所有 APP 都能存取、寫入 4 MODE_MULTI_PROCESS 允許多個 process 同時存取 寫入範例123456789101112Set&lt;String&gt; set = new HashSet&lt;String&gt;();set.add(&quot;秋天&quot;);set.add(&quot;冬天&quot;);SharedPreferences shp = getSharedPreferences(&quot;MyData&quot;,Context.MODE_PRIVATE);SharedPreferences.Editor editor = shp.edit();editor.putInt(&quot;NUMBER&quot;,900);editor.putString(&quot;USER&quot;, &quot;Boyd&quot;);editor.putFloat(&quot;WEIGHT&quot;, 55);editor.putStringSet(&quot;SEASON&quot;, set);editor.apply(); editor.apply()為非同步，可避免衝突editor.commit()亦可，不過可能會產生碰撞 讀取範例12345SharedPreferences shp = getSharedPreferences(&quot;MyData&quot;,Context.MODE_PRIVATE);String USER = shp.getString(&quot;USER&quot;,&quot;&quot;);int x = shp.getInt(&quot;NUMBER&quot;,0);Set&lt;String&gt; set2 = shp.getStringSet(&quot;SEASON&quot;, new HashSet&lt;String&gt;()); 寫成Class1234567891011121314151617181920212223242526272829303132333435363738package com.example.sharepreferences;import android.content.Context;import android.content.SharedPreferences;public class MyData{ private Context context; public MyData(Context context) { this.context = context; } public void saveInt(String fileName,String key,int value) { SharedPreferences shp = context.getSharedPreferences(fileName,Context.MODE_PRIVATE); SharedPreferences.Editor editor = shp.edit(); editor.putInt(key,value); editor.apply(); } public int loadInt(String fileName,String key) { SharedPreferences shp = context.getSharedPreferences(fileName,Context.MODE_PRIVATE); int x =shp.getInt(key,0); return x; } public void saveString(String fileName,String key,String value) { SharedPreferences shp = context.getSharedPreferences(fileName,Context.MODE_PRIVATE); SharedPreferences.Editor editor = shp.edit(); editor.putString(key,value); editor.apply(); } public String loadString(String fileName,String key) { SharedPreferences shp = context.getSharedPreferences(fileName,Context.MODE_PRIVATE); String s =shp.getString(key,&quot;&quot;); return s; }} 寫入、讀取 123456MyData myData = new MyData(getApplicationContext()); //不能傳遞thismyData.saveInt(&quot;Money&quot;,&quot;May&quot;,5000);myData.saveString(&quot;Money&quot;,&quot;Date&quot;,&quot;2020-05-11&quot;);int Money = myData.loadInt(&quot;Money&quot;,&quot;May&quot;);String Date = myData.loadString(&quot;Money&quot;,&quot;Date&quot;); getApplicationContext():返回該應用程式的上下文,生命週期是整個應用,應用摧毀它才摧毀。Activity.this:返回當前Activity的上下文,生命週期只是它所在的Activity,Activity 摧毀他就摧毀 參考資料SharedPreferences https://spicyboyd.blogspot.com/2018/04/appandroid-sharedpreferences.htmlActivity.this和getApplicationContext()的區別 https://www.itread01.com/p/57587.html","link":"/2020/11/17/Android%20SharedPreferences/"},{"title":"Android Studio 快捷鍵","text":"簡介幾個較常用的 Android Studio 的快捷鍵 說明 快捷鍵 功能 Alt + Enter 自動導包、修正錯誤 Shift + F2 移動到錯誤的地方 Shift + F6 重新命名 Shift + F10 自動執行APP F11 加入書籤 Shift + F11 顯示所有書籤 Ctrl + F 查找關鍵字 Ctrl + R 查找關鍵字與替換 Ctrl + H 顯示繼承關係的結構圖 Ctrl + Y 刪除該列 Ctrl + / 注釋程式碼(//)，可大區塊注釋選好的那幾列 Ctrl + ~ 切換編輯器的風格 Ctrl + F12 顯示當前程式碼的結構 Ctrl + Alt + T 自動生成 if、for、try等等 Ctrl + Alt + L 程式碼自動排版 Ctrl + Shift + / 生成/**/ Ctrl + Shift + A or N 開啟查找列表 Ctrl + Shift + J 合併兩行相鄰的代碼 Ctrl + Shift + U 改變大小寫 參考資料https://dotblogs.com.tw/kent2480/2015/07/08/151774","link":"/2021/01/23/Android%20Studio%20%E5%BF%AB%E6%8D%B7%E9%8D%B5/"},{"title":"Android Studio 書籤","text":"簡介Android Studio 的小工具-書籤 說明標記:在要標記的那列程式碼，按 F11 即可進行書籤標記。按 ctrl + F11 ，可選擇標記編號。 取消標記:在已被標記處按 F11 則可以取消原有的標記。 查看:按shift + F11 可查看所有被標記的地方，並跳轉到該處。","link":"/2021/01/23/Android%20Studio%20%E6%9B%B8%E7%B1%A4/"},{"title":"Android TextView元件滑動","text":"簡介Android TextView元件滑動使用方法 範例123456789&lt;!-- width和height要固定，不要用wrap_content，會出現null object reference的問題--&gt;&lt;TextView android:id=&quot;@+id/TV&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;60dp&quot; android:scrollbars=&quot;vertical&quot; android:fadeScrollbars=&quot;true&quot; android:background=&quot;#ffffff&quot;/&gt; 1234567891011121314151617181920textView = findViewById(R.id.TV);// 使TextView內容區可以滚动textView.setMovementMethod(ScrollingMovementMethod.getInstance());//TextView顯示併下拉到最下面textView.post(new Runnable() { @Override public void run() { //將內容接續在其後 textView.append(Data); //計算出最內容最下面的位置 int scrollAmount = textView.getLayout().getLineTop(textView.getLineCount()) - textView.getHeight(); //移動到最下面位置 if (scrollAmount &gt; 0) textView.scrollTo(0, scrollAmount); else textView.scrollTo(0, 0); }}); 參考資料https://blog.csdn.net/u014341735/article/details/78425437","link":"/2021/06/06/Android%20TextView%E5%85%83%E4%BB%B6%E6%BB%91%E5%8B%95/"},{"title":"Android UDP Client","text":"簡介UDP客戶端，包含發送與接收 範例權限 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; MainActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;public class MainActivity extends AppCompatActivity { //Port 和 IP public static final int DEST_PORT = 30055; public static final String DEST_IP = &quot;192.168.1.236&quot;; // 每筆數據傳送大小為4KB private static final int DATA_LEN = 4096; String TAG = &quot;UDP_Client&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } public void send(View view) { new Thread(new Runnable() { @Override public void run() { // 接收數據的大小 byte[] inBuff = new byte[DATA_LEN]; // 創建DatagramPacket來接收數據 DatagramPacket inPacket = new DatagramPacket(inBuff, inBuff.length); // 創建DatagramPacket來發送數據 DatagramPacket outPacket = null; try ( // 創建一個DatagramSocket各戶端，使用随機端口 DatagramSocket socket = new DatagramSocket()) { /***發送***/ //初始化發送用的DatagramSocket(它包含一個長度為0的字節數組) outPacket = new DatagramPacket(new byte[0], 0, InetAddress.getByName(DEST_IP), DEST_PORT); //要發送的內容 String sendData = &quot;sendData&quot;; byte[] buff = sendData.getBytes(); outPacket.setData(buff); socket.send(outPacket); /***讀取***/ // 讀取Socket中的數據。將讀到的數據放在inPacket封裝的字節數組中。 socket.receive(inPacket); //讀取到的內容 String recieveData = new String(inBuff, 0, inPacket.getLength()); Log.v(TAG, &quot;recieveData:&quot; + new String(inBuff, 0, inPacket.getLength())); } catch (Exception e) { Log.e(TAG, e.toString()); } } }).start(); }} activity_main.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:padding=&quot;10dp&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:onClick=&quot;send&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;傳送&quot;&gt;&lt;/Button&gt;&lt;/LinearLayout&gt; 參考資料https://blog.csdn.net/jiangxinyu/article/details/8161044","link":"/2021/06/06/Android%20UDP%20Client/"},{"title":"Android UI更新","text":"簡介在android系統中，不允許在非Main Thread去更新UI。因此本文將介紹幾種當我們在非主線程工作後要去更新UI時可採用的方法。 說明本文將介紹以下幾種在非Main Thread更新UI的方法:1.runOnUiThread()2.Handler runOnUiThread更新UI範例用runOnUiThread來更新UI，是一種比用Handler更新UI來得更為簡便的方式 MainActivity.java 12345678910111213141516171819202122232425262728293031323334import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView;public class MainActivity extends AppCompatActivity { private TextView TV; private static final int msgKey = 1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TV = (TextView) findViewById(R.id.TV); Thread thread = new Thread(runnable); //在非Main Thread所進行的工作 thread.start(); } private Runnable runnable = new Runnable() { @Override public void run() { runOnUiThread(new Runnable() { @Override public void run() { TV.setText(&quot;1234567&quot;); } }); } };} Handler更新UI範例在Thread中可透過Handler以傳遞訊息的方式來更新UI介面 MainActivity.java 12345678910111213141516171819202122232425262728293031323334353637383940414243import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.widget.TextView;public class MainActivity extends AppCompatActivity { private TextView TV; private static final int msgKey = 1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TV = (TextView)findViewById(R.id.TV); Thread thread = new Thread(runnable); //在非Main Thread所進行的工作 thread.start(); } private Runnable runnable = new Runnable() { @Override public void run() { Message msg = new Message(); msg.what = msgKey; mHandler.sendMessage(msg); } }; private Handler mHandler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); switch (msg.what){ case msgKey: TV.setText(&quot;1234567&quot;); break; default: break; } } };} 參考資料http://hsingjungchen.blogspot.com/2017/07/androidhandlerthreadui.html","link":"/2021/06/06/Android%20UI%E6%9B%B4%E6%96%B0/"},{"title":"Android 定位位置擷取","text":"簡介GPS定位、網路定位 說明GPS定位較網路定位來得精確，不過只適用於室外。在室內可用網路定位來獲取位置(記得開啟網路)。 GPS定位:透過GPS(全球定位系統)及 Wi-Fi 和行動數據來盡可能的判斷精確位置。網路定位:允許 API 使用 Wi-Fi 或行動數據來判斷裝置的位置。傳回的位置其準確度大約是以城市街區為單位。 註:如果一直抓不到網路定位，可先開啟GoogleMap定位一下自己的位置再試試。 範例權限1234&lt;!-- GPS精確定位 --&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;&gt;&lt;/uses-permission&gt;&lt;!-- Wi-Fi 或行動數據約略定位 --&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;&gt;&lt;/uses-permission&gt; 範例MainActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import androidx.core.content.ContextCompat;import android.Manifest;import android.content.Intent;import android.content.pm.PackageManager;import android.location.Location;import android.location.LocationManager;import android.os.Bundle;import android.provider.Settings;import android.view.View;import android.widget.TextView;import android.widget.Toast;public class MainActivity extends AppCompatActivity { TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.TV); //位置權限 if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED || ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED ) { requestPermissions(new String[]{Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION}, 100); } //開啟定位 LocationManager mLocationManager = (LocationManager) getSystemService(LOCATION_SERVICE); if (mLocationManager.isProviderEnabled(LocationManager.GPS_PROVIDER) || mLocationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER)) { } else { startActivity(new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS)); } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == 100) { if (grantResults[0] == PackageManager.PERMISSION_GRANTED &amp;&amp; grantResults[1] == PackageManager.PERMISSION_GRANTED) { } else { Toast.makeText(this, &quot;拒絕權限會導致程式中某些功能無法如常運作&quot;, Toast.LENGTH_SHORT).show(); } } } public void getLocation(View view) { //取得位置 double latitude = 0.0; double longitude = 0.0; String Tag = &quot;&quot;; LocationManager mLocationManager = (LocationManager) this.getSystemService(LOCATION_SERVICE); try { Location location = mLocationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER); Tag = &quot;GPS定位&quot;; if (location == null) { location = mLocationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER); Tag = &quot;NETWORK定位&quot;; } if (location != null) { //緯度 latitude = Double.valueOf(new java.text.DecimalFormat(&quot;#.000000&quot;).format(location.getLatitude())); //經度 longitude = Double.valueOf(new java.text.DecimalFormat(&quot;#.000000&quot;).format(location.getLongitude())); } else { Tag = &quot;無定位資料&quot;; } textView.setText(Tag+&quot; &quot;+&quot;E&quot; + longitude+&quot; &quot;+&quot;N&quot; + latitude); } catch (SecurityException e) { e.printStackTrace(); } }} activity_main.xml 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:padding=&quot;30dp&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/TV&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;獲取位置&quot; android:onClick=&quot;getLocation&quot; &gt;&lt;/Button&gt;&lt;/LinearLayout&gt; 參考資料https://ithelp.ithome.com.tw/articles/10250692","link":"/2021/06/06/Android%20%E5%AE%9A%E4%BD%8D%E4%BD%8D%E7%BD%AE%E6%93%B7%E5%8F%96/"},{"title":"Android檔案存取-FileInputStream&#x2F;FileOutputStream","text":"簡介Android裡的本地檔案存取 說明資料儲存在手機中APP的一個專用目錄下(每個APP都會有一個專用目錄):data/data/[package.name]/files/[file_name.*] EX:data/data/com.example.fileaccess/files/data1.txt該檔案可在Android Studio中的Device File Explore中察看 若使用者在設定中清除APP 儲存空間，則files所存的檔案會被清空(為Android本地資料) 範例以下範例為在Activity的環境下 創建檔案、存入檔案資料12345678910111213141516171819public void SaveFile() //存在內存裡{ try { //開啟檔案。若檔案不存在則會新創一個該檔名檔案 FileOutputStream fout = this.openFileOutput(&quot;data1.txt&quot;, Context.MODE_PRIVATE); fout.write(&quot;Hello\\n\\nHI&quot;.getBytes()); fout.flush(); fout.close(); Toast.makeText(this,&quot;Save Ok&quot;,Toast.LENGTH_SHORT).show(); } catch (IOException e) { Toast.makeText(this,&quot;Error&quot;,Toast.LENGTH_SHORT).show(); e.printStackTrace(); }} 指定操作模式:Context.MODE_PRIVATE = 0預設操作模式，該檔案是私有資料，只能被應用本身訪問，在該模式下，檔案依呈現的寫入，寫入的內容會覆蓋原檔案的內容 Context.MODE_APPEND = 32768模式會檢查檔案是否存在，存在的話，新資料會在原檔案資料後追加，否則會建立新檔案。 Context.MODE_WORLD_READABLE = 1表示當前檔案可以被其他應用讀取 Context.MODE_WORLD_WRITEABLE = 2表示當前檔案可以被其他應用寫入 讀取檔案資料1234567891011121314151617181920public void ShowFile(){ try { FileInputStream fin = openFileInput(&quot;data1.txt&quot;); BufferedReader br = new BufferedReader(new InputStreamReader(fin)); String line; while ((line = br.readLine()) != null) { Log.v(&quot;Tag&quot;,line); } fin.close(); } catch (IOException e) { e.printStackTrace(); }} 參考資料https://codertw.com/android-%E9%96%8B%E7%99%BC/351302/","link":"/2020/11/30/Android%20%E6%AA%94%E6%A1%88%E5%AD%98%E5%8F%96-FileInputStream&FileOutputStream/"},{"title":"Android檔案存取-SdCard","text":"簡介Android裡SdCard的檔案儲存(內存與外存) 說明SdCard外存資料儲存在SdCard裡。即使使用者在設定中清除該APP 儲存空間，儲存在SdCard外存裡的資料也不會被影響。 Environment.getExternalStorageDirectory().getAbsolutePath()方法可查詢SdCard檔案存取的位置。不過礙於權限看不到。 SdCard外存的資料可在sdcard資料夾中查看到。(可在Android Studio中的Device File Explore中察看)(sdcard/[file_name.*]) SdCard內存資料儲存在SdCard裡，該專案的資料夾中。若使用者在設定中清除APP 儲存空間，該專案SdCard內存資料會一同被清空。 Environment.getExternalStorageDirectory().getAbsolutePath()方法可查詢SdCard檔案存取的位置。不過礙於權限看不到。 SdCard內存的資料可在sdcard資料夾中查看到。(可在Android Studio中的Device File Explore中察看)(sdcard/Android/data/[package.name]/[file_name.*]) 權限需要存取SdCard的權限,添加在AndroidManifest 12&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; 範例以下範例為在Activity的環境下 要求權限123456789101112131415161718192021222324252627282930@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //取得存取權限 if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) { requestPermissions( new String[] { Manifest.permission.WRITE_EXTERNAL_STORAGE,Manifest.permission.READ_EXTERNAL_STORAGE },1); } else { init(); } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (grantResults[0] == PackageManager.PERMISSION_GRANTED &amp;&amp; grantResults[1] == PackageManager.PERMISSION_GRANTED ) { init(); } else { finish(); } } SdCard的存取路徑、建立SdCard內存資料夾12345678910111213141516171819202122232425File sdroot; //外存File approot;//內存private void init(){ if(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))//判斷SdCard卡狀態 { sdroot = Environment.getExternalStorageDirectory(); //SdCard卡存取檔案的路徑 Log.v(&quot;Tag&quot;, &quot;SD卡存取檔案路徑:&quot; + sdroot.getAbsolutePath()); //建立SD卡內存資料夾 approot = new File(sdroot, &quot;Android/data/&quot; + getPackageName() + &quot;/&quot;); if (!approot.exists()) { if (approot.mkdir()) //建立成功 { Log.v(&quot;Tag&quot;, &quot;mkdir OK&quot;); } else //建立失敗 { Log.v(&quot;Tag&quot;, &quot;mkdir X&quot;); } } }} Environment.getExternalStorageState()用來判斷SdCard卡狀態:若手機裝有SDCard，且可以進行讀寫，則該方法返回的值等於Environment.MEDIA_MOUNTED。 SdCard外存的存取新增123456789101112131415public void NewSdrootFile()//新增檔案在SD卡的外存{ File file1 = new File(sdroot,&quot;SdrootFile.txt&quot;); try { FileOutputStream fout = new FileOutputStream(file1); fout.write(&quot;OK\\n\\nHAHA&quot;.getBytes()); fout.close(); Toast.makeText(this,&quot;New OK&quot;,Toast.LENGTH_SHORT).show(); } catch (IOException e) { Log.v(&quot;Tag&quot;,&quot;New File&quot;+e.toString()); }} 讀取1234567891011121314151617181920212223public void ShowSdrootFile(){ File file1 = new File(sdroot,&quot;SdrootFile.txt&quot;); try { BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(file1))); String line; StringBuffer sb = new StringBuffer(); while ((line = br.readLine())!= null) { sb.append(line+&quot;\\n&quot;); } br.close(); Log.v(&quot;Tag&quot;,&quot;SdrootFileData: &quot;+sb); } catch (Exception e) { Log.v(&quot;Tag&quot;,&quot;讀取SdrootFileData失敗&quot;); }} SdCard內存的存取新增1234567891011121314151617public void NewApprootFile()//新增檔案在SD卡的內存{ File file1 = new File(approot,&quot;ApprootFile.txt&quot;); try { FileOutputStream fout = new FileOutputStream(file1); fout.write(&quot;OK1&quot;.getBytes()); fout.close(); Toast.makeText(this,&quot;New OK&quot;,Toast.LENGTH_SHORT).show(); } catch (IOException e) { Log.v(&quot;Tag&quot;,&quot;New File&quot;+e.toString()); }} 讀取1234567891011121314151617181920212223public void ShowApprootFile() { File file1 = new File(approot,&quot;ApprootFile.txt&quot;); try { BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(file1))); String line; StringBuffer sb = new StringBuffer(); while ((line = br.readLine())!= null) { sb.append(line+&quot;\\n&quot;); } br.close(); Log.v(&quot;Tag&quot;,&quot;ApprootFileData: &quot;+sb); } catch (Exception e) { Log.v(&quot;Tag&quot;,&quot;讀取ApprootFileData失敗&quot;); }} 完整程式碼MainActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import androidx.core.content.ContextCompat;import android.Manifest;import android.content.pm.PackageManager;import android.os.Bundle;import android.os.Environment;import android.util.Log;import android.view.View;import android.widget.TextView;import android.widget.Toast;import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStreamReader;public class MainActivity extends AppCompatActivity { TextView textView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.TV); //取得存取權限 if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) { requestPermissions( new String[] { Manifest.permission.WRITE_EXTERNAL_STORAGE,Manifest.permission.READ_EXTERNAL_STORAGE },1); } else { init(); } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (grantResults[0] == PackageManager.PERMISSION_GRANTED &amp;&amp; grantResults[1] == PackageManager.PERMISSION_GRANTED ) { init(); } else { finish(); } } File sdroot; //外存 File approot;//內存 private void init() { if(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))//判斷SdCard卡狀態 { sdroot = Environment.getExternalStorageDirectory(); //SdCard卡存取檔案的路徑 Log.v(&quot;Tag&quot;, &quot;SD卡存取檔案路徑:&quot; + sdroot.getAbsolutePath()); //建立SD卡內存資料夾 approot = new File(sdroot, &quot;Android/data/&quot; + getPackageName() + &quot;/&quot;); if (!approot.exists()) { if (approot.mkdir()) //建立成功 { Log.v(&quot;Tag&quot;, &quot;mkdir OK&quot;); } else //建立失敗 { Log.v(&quot;Tag&quot;, &quot;mkdir X&quot;); } } } } public void NewSdrootFile(View view)//新增檔案在SD卡的外存 { File file1 = new File(sdroot,&quot;SdrootFile.txt&quot;); try { FileOutputStream fout = new FileOutputStream(file1); fout.write(&quot;OK\\n\\nHAHA&quot;.getBytes()); fout.close(); Toast.makeText(this,&quot;New OK&quot;,Toast.LENGTH_SHORT).show(); } catch (IOException e) { Log.v(&quot;Tag&quot;,&quot;New File&quot;+e.toString()); } } public void ShowSdrootFile(View view) { File file1 = new File(sdroot,&quot;SdrootFile.txt&quot;); try { BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(file1))); String line; StringBuffer sb = new StringBuffer(); while ((line = br.readLine())!= null) { sb.append(line+&quot;\\n&quot;); } br.close(); textView.setText(sb); Log.v(&quot;Tag&quot;,&quot;SdrootFileData: &quot;+sb); } catch (Exception e) { textView.setText(&quot;&quot;); Log.v(&quot;Tag&quot;,&quot;讀取SdrootFileData失敗&quot;); } } public void NewApprootFile(View view)//新增檔案在SD卡的內存 { File file1 = new File(approot,&quot;ApprootFile.txt&quot;); try { FileOutputStream fout = new FileOutputStream(file1); fout.write(&quot;OK1&quot;.getBytes()); fout.close(); Toast.makeText(this,&quot;New OK&quot;,Toast.LENGTH_SHORT).show(); } catch (IOException e) { Log.v(&quot;Tag&quot;,&quot;New File&quot;+e.toString()); } } public void ShowApprootFile(View view) { File file1 = new File(approot,&quot;ApprootFile.txt&quot;); try { BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(file1))); String line; StringBuffer sb = new StringBuffer(); while ((line = br.readLine())!= null) { sb.append(line+&quot;\\n&quot;); } br.close(); textView.setText(sb); Log.v(&quot;Tag&quot;,&quot;ApprootFileData: &quot;+sb); } catch (Exception e) { textView.setText(&quot;&quot;); Log.v(&quot;Tag&quot;,&quot;讀取ApprootFileData失敗&quot;); } }} activity_main 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;新增檔案在SD卡的外存&quot; android:onClick=&quot;NewSdrootFile&quot;/&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;新增檔案在SD卡的內存&quot; android:onClick=&quot;NewApprootFile&quot;/&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;顯示在SD卡的外存檔案&quot; android:onClick=&quot;ShowSdrootFile&quot;/&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;顯示在SD卡的內存檔案&quot; android:onClick=&quot;ShowApprootFile&quot;/&gt; &lt;TextView android:id=&quot;@+id/TV&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt; 參考資料https://www.youtube.com/watch?v=HiRk_3tznoo&amp;list=PLDwsR4fO8zMYegLEYctGSsmFTu0QkcU6I&amp;index=63https://codertw.com/android-%E9%96%8B%E7%99%BC/351302/","link":"/2020/11/30/Android%20%E6%AA%94%E6%A1%88%E5%AD%98%E5%8F%96-SdCard/"},{"title":"Android 系統通知","text":"簡介基本的手機系統通知實作(通知欄中的通知) 說明本文使用Notification來演示最基本的信息通知 範例該範例除了通知使用者訊息，還可在點選通知後跳轉到特定的頁面 MainActivity.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import androidx.appcompat.app.AppCompatActivity;import androidx.core.app.NotificationCompat;import android.annotation.SuppressLint;import android.app.Notification;import android.app.NotificationChannel;import android.app.NotificationManager;import android.app.PendingIntent;import android.content.Intent;import android.os.Bundle;public class MainActivity extends AppCompatActivity { private NotificationManager manager; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); showNotification(); } private void showNotification() { //取得系統通知管理服務 manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); //如果是Android8.0以上的系统，需要新建一個通道 if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) { //new NotificationChannel(ID,Name,系統通知的優先權) @SuppressLint(&quot;WrongConstant&quot;) NotificationChannel channel = new NotificationChannel(&quot;ChannelId&quot;, &quot;訊息通知&quot;, NotificationManager.IMPORTANCE_MAX); manager.createNotificationChannel(channel); channel.setVibrationPattern(new long[]{0}); NotificationData(); } else { NotificationData(); } } private void NotificationData() { manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); //取得系統通知管理服務 Intent intent = new Intent(this, MainActivity.class); //PendingIntent pendingIntent=PendingIntent.getActivity(context,requestCode,intent對象,flags); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, 0); Notification builder = new NotificationCompat.Builder(this, &quot;chId&quot;) .setContentTitle(&quot;早安通知&quot;)//通知標題 .setContentText(&quot;喝豆漿配饅頭&quot;)//通知内容 .setSmallIcon(R.drawable.ic_baseline_accessibility_new_24)//通知裡的小圖案 .setContentIntent(pendingIntent)//點擊通知即調轉到剛剛所設定的頁面 .setAutoCancel(false)//完成跳轉後是否取消通知 .build(); manager.notify(1, builder);//顯示通知 }} 參考資料https://ithelp.ithome.com.tw/articles/10221118","link":"/2021/06/26/Android%20%E7%B3%BB%E7%B5%B1%E9%80%9A%E7%9F%A5/"},{"title":"Android自訂字體","text":"簡介自訂Android系統中的字體 說明自行從網路上下載文字檔案(OpenType 與 TrueType 皆可)。 另外可選用SIL開源字型授權的字體(SIL Open Font License 1.1)該授權可1 商用，不需付費、知會或標明作者。2 分享檔案、將檔案安裝於任何軟硬體中。3 自由修改。 在Android中使用字體將(.ttf/.otf)檔案放進專案(檔案位置app/src/main/assets/fonts) –&gt;在app夾按右鍵–&gt;New–&gt;Folder–&gt;Assets Folder 在assets創一fonts資料夾將檔案放進專案 使用範例123456Typeface custom_font = Typeface.createFromAsset(getAssets(), &quot;fonts/NaikaiFont-Regular.ttf&quot;);textView.setTypeface(custom_font);editText.setTypeface(custom_font); 參考資料http://tw.gitbook.net/android/android_custom_fonts.html","link":"/2021/01/07/Android%20%E8%87%AA%E8%A8%82%E5%AD%97%E9%AB%94/"},{"title":"Git基本語法","text":"簡介Git 常用基本語法 設定資料12git config --global user.name 'jinling707'git config --global user.email 'jinling707@gmail.com' 查看基本資料1git config -l 下載檔案1git clone https://github.com/jinling707/AndroidSQLiteExample.git 建立Git庫1git init 添加文件1git add README.md 建立遠端儲存庫1git remote add origin https://github.com/jinling707/AndroidSQLiteExample.git 查看遠端網址1git remote –v Git狀態1git status 把資料放到索引區12git add .git add P1.text 提交1git commit –m &quot;Commit Remark&quot; 要修改最後一次的 Commit 訊息，只需直接在 Commit 指令後面加上 –amend 即可 1git commit --amend -m &quot;revise Commit&quot; 查看提交歷史12345git loggit log -4git log --one linegit log --one line -4git log --graph --oneline 查看變動1git diff 新增分支1git branch BranchName 切換分支1git checkout BranchName 檢視所有分支包括本地分支和遠端分支1git branch -a 新增BranchName分支，並切換到該分之上1git checkout -b BranchName 刪除本地分支(不能在該分之上進行刪除)1git branch -d BranchName 根據 commit id 回覆到指定版本1git reset --hard commit_id 合併分支(PR=Pull Reruest =Merge)1git merge BranchName 取消合併1git merge --abort 將新分支推送至GitHub(可用於推送主分支、分支的Commit)1git push origin BranchName 強制推送本地分之狀態到遠端_通常用於本地分支與遠程分支不同時1git push -f origin BranchName 同步雲端資料(拉下雲端內容)git pull是git fetch和git merge兩個步驟的結合 1git pull origin BranchName 檢視遠端分支1git branch -r 刪除雲端分支(:表示刪除分支)1git push origin :BranchName","link":"/2020/12/02/Git%20%E5%9F%BA%E6%9C%AC%E8%AA%9E%E6%B3%95/"},{"title":"Java Timmer介紹","text":"簡介定期、延遲是我們在開發中常會用到的工具，其皆可用Timer來實現！ 說明以下介紹Timer比較常見的兩種使用方式1.在特定的時間執行一次程式2.在相同的間隔時間不斷的重複執行一段程式 範例先建立所要執行的程式Class 12345class TestTimerTask extends TimerTask { public void run() { System.out.println(&quot;Task執行：&quot;+(new Date()).toString()); }} 啟用Timer 12345678910long delay = 3000L; // 延遲開始的時間long period = 1000L; // 反覆的時間// 只執行一次Timer singleTimer = new Timer();singleTimer.schedule(new TestTimerTask(), delay);// 反覆執行Timer repeatTimer = new Timer();repeatTimer.schedule(new TestTimerTask(), delay, period); 停止Timer 1repeatTimer.cancel(); 參考資料https://www.ewdna.com/2011/12/java-timer.htmlhttps://matthung0807.blogspot.com/2020/09/java-timer-and-timertask.html","link":"/2021/06/04/Java%20Timmer%E4%BB%8B%E7%B4%B9/"},{"title":"Java DecimalFormat","text":"簡介DecimalFormat可以用來將我們所要表達的數值調整至我們所需要的樣式，是常會使用到的工具之一。 說明可以使用DecimalFormat來1.取得所需的位數(用#及0)2.可加入其他所需的字符3.可處理金錢表示中的千位分隔符號以上的應用都可以混著使用 使用範例因為內容比較簡單，直接演示範例。 12345678910111213141516171819double d = 12345.777; //數字格式化: #-&gt;數字少了不處理， 0-&gt;數字少了會補0//註:如果整小數部分過長，尾數會被切掉(4捨5入)；整數部分過長，不論是用'#'或'0'都不會被切掉String s0 = new DecimalFormat(&quot;000000.0000&quot;).format(d);String s1 = new DecimalFormat(&quot;0.####&quot;).format(d);//單取整數String s2 = new DecimalFormat(&quot;0&quot;).format(d);//加其他符號String s3 = new DecimalFormat(&quot;0.00%&quot;).format(d);String s4 = new DecimalFormat(&quot;$0&quot;).format(d);//數字每三位用逗號分開String s5 = new DecimalFormat(&quot;,000&quot;).format(d);//註:以上的應用都可以混著使用String s6 = new DecimalFormat(&quot;$,000.000&quot;).format(d); 結果: 12345678s0-&gt;012345.7770s1-&gt;12345.777s2-&gt;12346s3-&gt;1234577.70%s4-&gt;$12346s5-&gt;12,346s6-&gt;$12,345.777","link":"/2021/02/20/Java%20DecimalFormat/"},{"title":"Java 日期時間","text":"簡介Java日期時間的取得、時間加減、時間格式 使用範例時間取得123Date date = new Date(); SimpleDateFormat SDF = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;);System.out.println(&quot;現在時間:&quot;+SDF.format(date.getTime())); 結果: 1現在時間:2020-11-14 03:16:14 時間加減Date.getTime()所返回的值為long(長度13)，表示毫秒。在做時間的加減以此邏輯去設計即可。 123456789101112Date date = new Date(); SimpleDateFormat SDF = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;);long Second = 30; System.out.println(&quot;現在時間:&quot;+SDF.format(date.getTime()));//加30秒System.out.println(&quot;加30秒:&quot;+SDF.format(date.getTime()+Second*1000));//減30秒System.out.println(&quot;減30秒:&quot;+SDF.format(date.getTime()-Second*1000)); 結果: 123現在時間:2020-11-14 03:18:23加30秒:2020-11-14 03:18:53減30秒:2020-11-14 03:17:53 時間格式時間的表示主要用SimpleDateFormat來設計，有許多的格式字母可運用來設計出所需的日期樣式，以下介紹幾個常用的，詳細可以參考JAVA API: https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html 或是 https://www.runoob.com/java/java-date-time.html G:西元 y:年 M:月 d:日 h:小時(12進制) H:小時(24進制) m:分 s:秒 S:毫秒 E:星期幾 a:AM/PM標記12345678910Date date = new Date(); SimpleDateFormat SDF1 = new SimpleDateFormat (&quot;Gy年M月d日-E ah時m分s秒&quot;);System.out.println(SDF1.format(date.getTime()));SimpleDateFormat SDF2 = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;); System.out.println(SDF2.format(date.getTime()));SimpleDateFormat SDF3 = new SimpleDateFormat (&quot;MMMd日&quot;);System.out.println(SDF3.format(date.getTime())); 結果: 123西元2020年11月14日-星期六 下午3時18分47秒2020-11-14 03:18:47十一月14日","link":"/2020/11/14/Java%20%E6%97%A5%E6%9C%9F%E6%99%82%E9%96%93/"},{"title":"RGB透明顏色值","text":"簡介RGB 與 透明度表示 說明RGB任何一種顏色的值範圍都是 0到 255(00到 ff)可在顏色前，加上透明度 [透明度][紅色R][綠色G][藍色B]範例:#00FF00FF 不透明度 16進制值 100% FF 95% F2 90% E6 85% D9 80% CC 75% BF 70% B3 65% A6 60% 99 55% 8C 50% 80 45% 73 40% 66 35% 59 30% 4D 25% 40 20% 33 15% 26 10% 1A 5% 0D 0% 00 工具色碼表＆顏色調色盤 https://www.toolskk.com/color配色模板 https://coolors.co/palettes/popular","link":"/2020/12/28/RGB%E9%80%8F%E6%98%8E%E9%A1%8F%E8%89%B2%E5%80%BC/"},{"title":"Java 進制轉換","text":"簡介Java 十進制與其他進制間相互的轉換 使用範例其他進制轉成十進制:123String numSt = &quot;1A11&quot;;Integer.parseInt(numSt,16); //第一個參數:要轉成十進制的數。第二個參數:該數原本的進制。Integer.valueOf(numSt,16); //同上。 註:兩者都可以實現進制轉換，差異主要在用於比較(數值 == 數值 及 .equal(Object))的時候，可查看 https://blog.csdn.net/jerry11112/article/details/107003036 十進制轉成其他進制12int num = 18; Integer.toString(num, 3); //第一個參數:要轉換的十進制數。第二個參數:欲轉成的進制。 另外還有其他方法: 十進制轉二進制Integer.toBinaryString(int i) 十進制轉八進制Integer.toOctalString(int i) 十進制轉十六進制Integer.toHexString(int i)","link":"/2020/11/14/Java%20%E9%80%B2%E5%88%B6%E8%BD%89%E6%8F%9B/"},{"title":"Android SQLite","text":"簡介Android中本地的數據資料庫 說明SQLite不像一般大型資料庫，需先建立好資料庫的實體(如:建立資料庫、建立資料表、計設資料表欄位等)，再經由程式進行存取。SQLite是經由 Android幫你建立的，建立SQLite需要繼承 SQLiteOpenHelper 可在Android Debug Database來查看手機資料庫的狀況 使用Android Debug Database(需使用手機而非模擬器，並開啟網路)在 module 的 build.gradle 中添加 1debugImplementation 'com.amitshekhar.android:debug-db:1.0.0' 在執行時，查找Logcat裡 1D/DebugDB: Open http://XXX.XXX.X.XXX:8080 in your browser 並在瀏覽器中打開網址，便可察看手機資料庫 範例建立資料庫 DBHelper.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;import androidx.annotation.Nullable;public class DBHelper extends SQLiteOpenHelper{ private final static int DBVersion = 1; //版本 private final static String DBName = &quot;SampleList.db&quot;; //資料庫名 public final static String TableName = &quot;MySample&quot;; //資料表名 public DBHelper(@Nullable Context context) { super(context, DBName, null, DBVersion); } public static final String ID = &quot;_id&quot;; //primary key 的名字要設定為 _id public static final String NAME = &quot;name&quot;; public static final String GENDER = &quot;gender&quot;; public static final String ADDRESS = &quot;address&quot;; public static final String BIRTH = &quot;birth&quot;; public static final String WEIGHT = &quot;weight&quot;; public static final String TIME = &quot;time&quot;; public static final String PHONE = &quot;phone&quot;; /** 如果 Android 載入時找不到生成的資料庫檔案，就會觸發 onCreate()，所以產生資料表的 SQL 要寫在onCreate()裡。 一個資料庫可新增、使用多個資料表。 新增資料表: CREATE TABLE IF NOT EXISTS 表格名 (欄位1 資料種類,欄位 2 資料種類, ... ); */ @Override public void onCreate(SQLiteDatabase db) { //版本一 final String SQL = &quot;CREATE TABLE &quot;+ TableName + &quot;(&quot; + ID + &quot; INTEGER PRIMARY KEY AUTOINCREMENT&quot; + &quot;,&quot; + NAME + &quot; TEXT NOT NULL&quot; + &quot;,&quot; + GENDER + &quot; VARCHAR(10) DEFAULT 'man'&quot; + &quot;,&quot; + ADDRESS + &quot; VARCHAR(50)&quot; + &quot;,&quot; + BIRTH + &quot; DATE NOT NULL&quot; + &quot;,&quot; + WEIGHT + &quot; FLOAT(2)&quot; + &quot;,&quot; + TIME + &quot; TIME&quot; +&quot;)&quot;; db.execSQL(SQL); } /** 如果資料庫結構有改變了就會觸發 onUpgrade，需在onUpgrade()中新增兩版本間差異的部分 oldVersion為上一次執行時所用的版本 newVersion為我們透過建構子裡super給SQLiteOpenHelper的值 **/ @Override public void onUpgrade(SQLiteDatabase db,int oldVersion, int newVersion)// { }} 常見資料型態數字INTEGER:介於 -2,147,483,648 與 2,147,483,647 間的整數FLOAT:FLOAT(n) n是儲存 float 數字的小數位數，介於 1 與 53 間DOUBLE 字符CHARVARCHARTEXT:可放2的16次方減1個字元，用來儲存大量的資料 時間DATE:日期欄位,格式 yyyy-mm-dd, 範圍 1000-01-01 ~ 19999-12-3。TIME:格式 hh:mm:dd,範圍 -838:59:59 ~ 838:59:59。YEAR:記錄年份,範圍 1901 ~ 2155。DATETIME:日期加上時間,格式yyyy-mm-dd hh:mm:ss,範圍 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。 PRIMARY KEY AUTOINCREMENT該欄位的數值會自動編號,每增一筆資料時,此欄位自動把編號加一。(此欄位須為索引(主键)、數值資料型態，一個資料表只能有一個欄位使用)。 使用資料庫 CRUD.java操作資料庫的增、刪、改、查 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import android.content.ContentValues;import android.content.Context;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import android.util.Log;public class CRUD{ DBHelper dbHandler; SQLiteDatabase db; Context mContext; private static final String[] columns = { DBHelper.ID, DBHelper.NAME, DBHelper.GENDER, DBHelper.ADDRESS, DBHelper.BIRTH, DBHelper.WEIGHT, DBHelper.TIME }; public CRUD(Context context) { mContext = context; } public void open() //開啟資料庫 { dbHandler = new DBHelper(mContext); db = dbHandler.getWritableDatabase(); } public void close() //關閉資料庫 { dbHandler.close(); } public long add() { int r =(int)(Math.random()*1000); ContentValues contentValues = new ContentValues(); //ID 為 AUTOINCREMENT contentValues.put( DBHelper.NAME, &quot;小每&quot;+r); contentValues.put( DBHelper.GENDER, &quot;woman&quot;); contentValues.put( DBHelper.ADDRESS, &quot;太平洋3街&quot;); contentValues.put( DBHelper.BIRTH, &quot;2050-01-01&quot;); contentValues.put( DBHelper.WEIGHT, 45.45687); contentValues.put( DBHelper.TIME, &quot;21:59:59&quot;); //return ID(AUTOINCREMENT)的值，失敗為-1 return db.insert(DBHelper.TableName, null, contentValues); } public int delete(String ID) { //return 成功:1，失敗為0 return db.delete(DBHelper.TableName, DBHelper.ID + &quot;=?&quot;, new String[] {ID}); // 也可這樣寫 db.delete(DBHelper.TableName, DBHelper.ID + &quot;=\\&quot;&quot; + ID+&quot;\\&quot;&quot;, null); } public int update(String ID) { int r =(int)(Math.random()*1000); ContentValues contentValues = new ContentValues(); contentValues.put( DBHelper.NAME, &quot;小華&quot;+r); contentValues.put( DBHelper.GENDER, &quot;man&quot;); contentValues.put( DBHelper.ADDRESS, &quot;太平洋5街&quot;); contentValues.put( DBHelper.BIRTH, &quot;2050-11-01&quot;); contentValues.put( DBHelper.WEIGHT, 22.478687); //return 成功:1，失敗為0 return db.update(DBHelper.TableName, contentValues,DBHelper.ID + &quot;=?&quot;,new String[] {ID}); } public void check() { Cursor cursor = db.query(DBHelper.TableName,columns,DBHelper.GENDER+&quot;=?&quot;,new String[]{&quot;man&quot;},null, null, null); if(cursor.getCount() &gt; 0) //多筆數量 { while(cursor.moveToNext()) { String NAME = cursor.getString(cursor.getColumnIndex(DBHelper.NAME)); Float WEIGHT = cursor.getFloat(cursor.getColumnIndex(DBHelper.WEIGHT)); Log.v(&quot;Tag&quot;,&quot;查到的資料為: &quot;+NAME+&quot; &quot;+ WEIGHT); } } }} 比對、找尋的欄位資料為2個以上時whereClause/selection:欄位1 = ? and 欄位2 = ? whereArgs/selectionArgs:不用管資料型態，就算該欄位資料為數字，也是放字串資料new String[]{“欄位1值”,”欄位2值”} EX:刪除 1db.delete(DBHelper.TableName, DBHelper.ID + &quot;=? and &quot;+DBHelper.GENDER+&quot; =?&quot;, new String[] {ID,&quot;woman&quot;}); 查看 1db.query(DBHelper.TableName,columns,DBHelper.ID+&quot; =? and &quot;+DBHelper.GENDER + &quot; =?&quot;,new String[]{&quot;2&quot;,&quot;woman&quot;},null, null, null); 刪除資料表db.delete(資料表名, null, null); 1db.delete(DBHelper.TableName, null, null); 設定主鍵(自動遞增)為0update sqlite_sequence set seq=0 where name=’資料表名’ 1db.execSQL(&quot;update sqlite_sequence set seq=0 where name='&quot;+ DBHelper.TableName +&quot;'&quot;); MainActivity.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.EditText;public class MainActivity extends AppCompatActivity{ CRUD crud; EditText ET; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ET = findViewById(R.id.ET); } public void add(View view) { crud = new CRUD(getApplicationContext()); crud.open(); long i = crud.add(); Log.v(&quot;Tag&quot;,&quot;add&quot;+i); crud.close(); } public void delete(View view) { crud = new CRUD(getApplicationContext()); crud.open(); crud.delete(ET.getText().toString()); crud.close(); } public void update(View view) { crud = new CRUD(getApplicationContext()); crud.open(); crud.update(ET.getText().toString()); crud.close(); } public void check(View view) { crud = new CRUD(getApplicationContext()); crud.open(); crud.add(); crud.check(); }} activity_main.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;增&quot; android:onClick=&quot;add&quot;/&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;查&quot; android:onClick=&quot;check&quot;/&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;5dp&quot; android:background=&quot;#303F9F&quot;/&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;刪/改 ID&quot; android:textColor=&quot;#ff0000&quot;/&gt; &lt;EditText android:id=&quot;@+id/ET&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;#ff0000&quot;/&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;刪&quot; android:onClick=&quot;delete&quot; android:textColor=&quot;#ff0000&quot;/&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;改&quot; android:onClick=&quot;update&quot; android:textColor=&quot;#ff0000&quot;/&gt; &lt;/LinearLayout&gt; 資料庫Update說明APP開展的過程中，若需要修改、更動資料庫，可直接在設定中清除APP資料。然後重新建立資料庫。若是產品已經發布，或是需要保留原先資料庫數據，就必須用Upgrade的方式。Upgrade可讓SQLite新增欄位，但不能對舊欄位做刪改，如欄位名稱、型態都不能改，當然也不能刪除。若真需要做欄位的刪改，須將原先資料庫設為暫時資料庫，待建立新資料庫後，再將資料搬移到新資料庫中。 資料庫Update範例1.將新版本的資料表寫在onCreate(如下onCreate的表已改為”版本二”的)2.修改版本變數 DBVersion = 2(該值透過建構子裡super給SQLiteOpenHelper)3.在onUpgrade()中新增兩版本間差異的部分，可用switch來判斷舊版本與新版本間需要做甚麼修改 DBHelper.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;import androidx.annotation.Nullable;public class DBHelper extends SQLiteOpenHelper{ private final static int DBVersion = 2; //版本 private final static String DBName = &quot;SampleList.db&quot;; //資料庫名 public final static String TableName = &quot;MySample&quot;; //資料表名 public DBHelper(@Nullable Context context) { super(context, DBName, null, DBVersion); } public static final String ID = &quot;_id&quot;; //primary key 的名字要設定為 _id public static final String NAME = &quot;name&quot;; public static final String GENDER = &quot;gender&quot;; public static final String ADDRESS = &quot;address&quot;; public static final String BIRTH = &quot;birth&quot;; public static final String WEIGHT = &quot;weight&quot;; public static final String TIME = &quot;time&quot;; public static final String PHONE = &quot;phone&quot;; /** 如果 Android 載入時找不到生成的資料庫檔案，就會觸發 onCreate()，所以產生資料表的 SQL 要寫在onCreate()裡。 一個資料庫可新增、使用多個資料表。 新增資料表: CREATE TABLE IF NOT EXISTS 表格名 (欄位1 資料種類,欄位 2 資料種類, ... ); */ @Override public void onCreate(SQLiteDatabase db) { //版本二 final String SQL = &quot;CREATE TABLE &quot;+ TableName + &quot;(&quot; + ID + &quot; INTEGER PRIMARY KEY AUTOINCREMENT&quot; + &quot;,&quot; + NAME + &quot; TEXT NOT NULL&quot; + &quot;,&quot; + GENDER + &quot; VARCHAR(10) DEFAULT 'man'&quot; + &quot;,&quot; + ADDRESS + &quot; VARCHAR(50)&quot; + &quot;,&quot; + BIRTH + &quot; DATE NOT NULL&quot; + &quot;,&quot; + WEIGHT + &quot; FLOAT(2)&quot; + &quot;,&quot; + TIME + &quot; TIME&quot; + &quot;,&quot; + PHONE + &quot; TEXT&quot; +&quot;)&quot;; db.execSQL(SQL); } /** 如果資料庫結構有改變了就會觸發 onUpgrade，需在onUpgrade()中新增兩版本間差異的部分 oldVersion為上一次執行時所用的版本 newVersion為我們透過建構子裡super給SQLiteOpenHelper的值 **/ @Override public void onUpgrade(SQLiteDatabase db,int oldVersion, int newVersion)// { //用switch來判斷舊版本與新版本間需要做甚麼修改 switch (oldVersion) { case 1: //方法一:新增兩版本差異的部分 String sql = &quot;ALTER TABLE &quot; + TableName + &quot; ADD &quot; + PHONE + &quot; TEXT&quot;; db.execSQL(sql);// //方法二:使用TEMP搬移資料// //將舊資料表重新命名// db.execSQL(&quot;ALTER TABLE &quot;+TableName +&quot; RENAME TO &quot;+&quot;TEMP_TABLE&quot;);// //建立新資料表// db.execSQL(&quot;DROP TABLE IF EXISTS &quot;+TableName);// final String SQL =// &quot;CREATE TABLE &quot;+ TableName// + &quot;(&quot;// + ID + &quot; INTEGER PRIMARY KEY AUTOINCREMENT&quot; + &quot;,&quot;// + NAME + &quot; TEXT NOT NULL&quot; + &quot;,&quot;// + GENDER + &quot; VARCHAR(10) DEFAULT 'man'&quot; + &quot;,&quot;// + ADDRESS + &quot; VARCHAR(50)&quot; + &quot;,&quot;// + BIRTH + &quot; DATE NOT NULL&quot; + &quot;,&quot;// + WEIGHT + &quot; FLOAT(2)&quot; + &quot;,&quot;// + TIME + &quot; TIME&quot; + &quot;,&quot;// + PHONE + &quot; TEXT&quot;// +&quot;)&quot;;// db.execSQL(SQL);// //將舊資料insert到新的資料表// db.execSQL(&quot;INSERT INTO &quot;+TableName+&quot; (&quot;+NAME+&quot;, &quot;+BIRTH+&quot;) &quot; +&quot;SELECT &quot;+NAME+&quot;,&quot;+ BIRTH +&quot; FROM &quot;+&quot;TEMP_TABLE&quot;);// //刪除舊資料表// db.execSQL(&quot;DROP TABLE IF EXISTS &quot;+&quot;TEMP_TABLE&quot;); break; case 2: break; } }} 若是單純的增加資料表欄位，在onUpgrade可用方法一來新增兩版本差異的部分而若是資料表需要修、刪，可用方法二，將原先資料庫設為暫時資料庫，待建立新資料庫後，再將資料搬移到新資料庫中。 註:Android的SQLite省去了一些標準SQL的特性，並且加入了一些自己的新特性,因此ALTER TABLE ADD的部分不能一次添加多個欄位，需要一個一個慢慢加，如下 1234String sql = &quot;ALTER TABLE &quot; + TableName + &quot; ADD &quot; + PHONE + &quot; TEXT&quot;;db.execSQL(sql);String sql2 = &quot;ALTER TABLE &quot; + TableName + &quot; ADD &quot; + PHONE2 + &quot; TEXT&quot;;db.execSQL(sql2); 參考資料Android Debug Database:https://www.itread01.com/content/1544582526.htmlSQLite:https://sweeteason.pixnet.net/blog/post/37364146-android-%E4%BD%BF%E7%94%A8-sqlite-%E8%B3%87%E6%96%99%E5%BA%AB%E7%9A%84%E6%96%B9%E6%B3%95onUpgrade:https://mrraybox.blogspot.com/2017/01/android-sqlite-onupgrade.htmlhttps://ithelp.ithome.com.tw/articles/10188563SQL資料型態:https://codingboy.pixnet.net/blog/post/26919164PHP+MySQL 快速入門(滄海) 檔案下載檔案下載: Download Code","link":"/2020/11/30/Android%20SQLite/"}],"tags":[{"name":"美工","slug":"美工","link":"/tags/%E7%BE%8E%E5%B7%A5/"},{"name":"Android Service","slug":"Android-Service","link":"/tags/Android-Service/"},{"name":"Android檔案資料存取","slug":"Android檔案資料存取","link":"/tags/Android%E6%AA%94%E6%A1%88%E8%B3%87%E6%96%99%E5%AD%98%E5%8F%96/"},{"name":"Android Studio 小工具","slug":"Android-Studio-小工具","link":"/tags/Android-Studio-%E5%B0%8F%E5%B7%A5%E5%85%B7/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"美編","slug":"美編","link":"/categories/%E7%BE%8E%E7%B7%A8/"}]}